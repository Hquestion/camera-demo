<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>camera demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<button onclick="live()" style="display: none;">Video播放摄像头,绘制到canvas上</button>
<button onclick="record()" style="display: none;">录制摄像头输出的stream，保存数据，并绘制到canvas</button>

<div style="margin-top: 10px">
    <a id="download">下载</a>
    <button onclick="stop()">停止</button>
    <button onclick="record()">开始</button>
</div>
<video id="player" controls autoplay style="display: none;"></video>
<canvas>

</canvas>
<script>
    // 摄像头视频流录制状态
    var stopped = false, shouldStop = false;
    // 定时器ID
    var canvasRenderTimer = null, recordTimer = null;


    var width = window.innerWidth;
    var height = window.innerHeight;

    var player = document.getElementById('player');
    var canvas = document.querySelector('canvas');
    var ctx = canvas.getContext('2d');
    var downloadLink = document.querySelector('#download');

    player.onloadedmetadata = function(e) {
        width = player.videoWidth;
        height = player.videoHeight;

        canvas.width = width;
        canvas.height = height;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
    };

    var live = function() {
        shouldStop = true;
        navigator.mediaDevices.getUserMedia({ audio: true, video: true })
            .then(function(stream) {
                player.srcObject = stream;

                var drawVideo = function(ctx) {
                    canvasRenderTimer = requestAnimationFrame(function() {
                        drawVideo(ctx);
                    });
                    ctx.drawImage(player, 0, 0);
                };
                cancelAnimationFrame(canvasRenderTimer);
                drawVideo(ctx);
            });
    };

    var record = function() {
        shouldStop = false;
        stopped = false;
        cancelAnimationFrame(canvasRenderTimer);
        navigator.mediaDevices.getUserMedia({ audio: true, video: true })
            .then(function(stream) {

                player.srcObject = stream;

                const options = {mimeType: 'video/webm'};
                const recordedChunks = [];
                const mediaRecorder = new MediaRecorder(stream, options);
                mediaRecorder.addEventListener('dataavailable', function(e) {
                    console.log(e);
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                        // 向后端发送数据,Demo先将分片展示到页面上
                        // console.log('发送给后端的视频流分片：', e.data);
                        // var player = document.createElement('video');
                        // player.autoplay = true;
                        // player.controls = true;
                        // // FIXME 第二个分片开始不能播放，这里要看一下能不能通过MediaSource解决
                        // let url = URL.createObjectURL(new Blob([e.data]));
                        // player.src = url;
                        // document.body.appendChild(player);

                        ctx.clearRect(0,0,width, height);
                        // 先直接用video来实时绘制，应该也可以绘制采集的分片。比如后端对视频进行了处理，那这里可以绘制处理后的视频
                        ctx.drawImage(player, 0, 0);
                        ctx.save();
                        randomRect().then(function(rect){
                            // record停止后，停止绘制
                            if (shouldStop || stopped) return;
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = "#f00";
                            ctx.strokeWidth=1;
                            ctx.beginPath();
                            ctx.rect(rect.x, rect.y, rect.width, rect.height);
                            ctx.stroke();
                            ctx.closePath();
                            ctx.restore();
                        });
                    }

                    if(shouldStop === true && stopped === false) {
                        mediaRecorder.stop();
                        stopped = true;
                    }
                });

                mediaRecorder.addEventListener('stop', function() {
                    downloadLink.href = URL.createObjectURL(new Blob(recordedChunks));
                    downloadLink.download = 'acetest.webm';
                });

                mediaRecorder.start(10);
            });
    };

    const minWidth = 50;
    const minHeight = 50;

    function randomRect() {
        var cordx = 0, cordy = 0, rectWidth = minWidth, rectHeight = minHeight;
        rectWidth = Math.max(Math.ceil(Math.random() * width / 2), minWidth);
        rectHeight = Math.max(Math.ceil(Math.random() * height / 2), minHeight);
        cordx = Math.floor(Math.random() * (width - rectWidth));
        cordy = Math.floor(Math.random() * (height - rectHeight));

        let _resolve;
        // 模拟接口调用，延迟100ms返回坐标
        setTimeout(() => {
            _resolve({
                x: cordx,
                    y: cordy,
                width: rectWidth,
                height: rectHeight
            });
        }, 100);
        return new Promise((resolve, reject) => {
            _resolve = resolve;
        });
    }

    var stop = function() {
        shouldStop = true;
    }

</script>
</body>
</html>